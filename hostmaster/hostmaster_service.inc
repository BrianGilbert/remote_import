<?php
 // $Id$

 /**
  * @file
  *   A 'hostmaster' implementation of the 'remote_import' service type.
  */

/**
 * A class containing the 'hostmaster' implementation of the 'remote_import' service.
 *
 * This class is conditionally loaded when the "--remote_import_service_type=hostmaster"
 * option is passed to provision-save commands run on servers.
 *
 * The above flag is generated by the hosting counterpart of this class, which
 * provides the front end to configure all these fields.
 *
 * The responsibilities of this class include responding and saving any
 * values that are passed to it, and also to override the portions of
 * the public API for this service that are necessary.
 */
class provisionService_remote_import_hostmaster extends provisionService_remote_import {
 /**
  * Some common options handled upstream by the base service classes.
  */

  /**
   * Initialize this class, including option handling.
   */
  function init() {
    // REMEMBER TO CALL THE PARENT!
    parent::init();
    /**
     * Setting and storing a value.
     *
     * You will most commonly use :
     *    $this->server->setProperty('remote_import_field', 'default');
     *
     * This helper will check for an existing saved value, overridden
     * by a command line option falling back to the default.
     *
     * This is the format used by everything you want configurable from
     * the front end or command line.
     *
     * These values will be saved in ~/.drush/server_name.drush.alias.inc.
     */
    $this->server->setProperty('remote_import_field', 'default');
  }
  
  function list_sites() {
    $sites = array();
    
    //$result = $this->remote_execute('@hostmaster status', array());
    
    // We talk to the remote Aegir, and get it to list the sites it has.
    // We need to bootstrap the remote hostmaster.
    $lines[] = 'drush_bootstrap(DRUSH_BOOTSTRAP_DRUPAL_FULL)';
    $lines[] = '$sites = array()';
    $lines[] = '$result = db_query(\'SELECT hs.nid, n.title FROM {hosting_site} hs INNER JOIN {node} n ON hs.nid = n.nid WHERE hs.status = %d\', HOSTING_SITE_ENABLED)';
    $lines[] = 'while ($nid = db_fetch_object($result)) {';
    $lines[] = '  $sites[$nid->nid] = $nid->title';
    $lines[] = '}';
    // Set the $sites array into the backend result, so we can extract it easily
    // later.
    $lines[] = 'drush_backend_set_result($sites)';
    
    // Execute the PHP we wrote in $lines on the remote server.
    $result = $this->remote_execute('@hostmaster php-eval', array(implode(';', $lines) . ';'));
    
    // If the PHP suceeeds, the result will be in the 'object' key.
    if (isset($result['object']) && is_array($result['object'])) {
      return $result['object'];
    }
    
    return FALSE;
  }
  
  function remote_execute($command, $data = array()) {
    $data += array(
      'root' => NULL,
      'uri' => NULL,
    );
    return drush_backend_invoke($command, $data, 'POST', TRUE, NULL, $this->server->remote_host, $this->server->script_user);
  }
  
  function fetch_site($site) {
    // Do a backup on the remote server.
    $remote_backup_file = $this->remote_backup($site);
    
    // And now fetch that backup.
    $local_file = d('@hostmaster')->platform->server->backup_path . '/' . basename($remote_backup_file);
    $this->fetch($remote_backup_file, $local_file);
    
    // And now delete the backup just fetched.
    $this->remote_execute('provision-backup_delete', array($remote_backup_file));
    
    return $local_file;
  }
  
  function fetch($path, $dest) {
    $options = array(
      'omit-dir-times' => TRUE,
    );
    if (drush_core_call_rsync(escapeshellarg($this->server->script_user . '@' . $this->server->remote_host . ':/') . $path, $dest, $options, TRUE, FALSE)) {
      drush_log(dt('@path has been fetched from remote server @remote_host.', array(
        '@path' => $path, 
        '@remote_host' => $this->server->remote_host))
      );
    }
    else {
      drush_set_error('PROVISION_FILE_SYNC_FAILED', dt('@path could not be fetched from remote server @remote_host.' .
        ' Changes might not be available until this has been done. (error: %msg)', array(
          '@path' => $path, 
          '@remote_host' => $this->server->remote_host, 
          '%msg' => join("\n", drush_shell_exec_output())))
      );
    }
  }
  
  function remote_backup($site) {
    $result = $this->remote_execute('@' . $site . ' provision-backup');
    
    if (isset($result['context']['backup_file'])) {
      return $result['context']['backup_file'];
    }
    
    return FALSE;
  }
  

  /**
   * Implementation of service verify.
   */
  function verify() {
    parent::verify();
    if ($this->context->type == 'server') {
      // Create the configuration file directory.
      provision_file()->create_dir($this->server->remote_import_config_path, dt("Example configuration"), 0700);
      // Sync the directory to the remote server if needed.
      $this->sync($this->server->remote_import_config_path);
    }
  }
}
